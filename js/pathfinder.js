// Generated by CoffeeScript 1.6.1
(function() {
  var Pathfinder;

  Pathfinder = (function() {

    function Pathfinder(startCol, startRow, targetCol, targetRow) {
      var finished, i, node, row, tile, _i, _j, _k, _len, _len1, _ref, _ref1;
      this.startCol = startCol;
      this.startRow = startRow;
      this.targetCol = targetCol;
      this.targetRow = targetRow;
      this.open = this.closed = [];
      _ref = game.level.tiles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          tile = row[_j];
          tile.fill = null;
        }
      }
      game.level.tiles[this.targetRow][this.targetCol].fill = "#ff0000";
      game.level.tiles[this.startRow][this.startCol].fill = "#00ff00";
      this.nodeMap = [];
      for (i = _k = 0, _ref1 = game.level.rows; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        this.nodeMap[i] = [];
      }
      this.addToOpenList({
        col: this.startCol,
        row: this.startRow,
        g: 0,
        f: 0
      });
      finished = 0;
      while (!finished) {
        node = this.findSmallestF();
        this.open.splice(this.open.indexOf(node), 1);
        this.nodeMap[node.row][node.col].state = 'c';
        if (!node) {
          finished = 1;
        } else if (node.row === this.targetRow && node.col === this.targetCol) {
          while (node) {
            if (!(node.row === this.startRow && node.col === this.startCol) && !(node.row === this.targetRow && node.col === this.targetCol)) {
              game.level.tiles[node.row][node.col].fill = "#fff";
            }
            node = node.parent;
          }
          finished = 1;
        } else {
          this.processAdjacentTiles(node);
        }
      }
    }

    Pathfinder.prototype.processAdjacentTiles = function(node) {
      var col, f, g, h, i, j, movementCost, newNode, row, tile, _i, _results;
      _results = [];
      for (i = _i = -1; _i <= 1; i = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (j = _j = -1; _j <= 1; j = ++_j) {
            if (i === 0 && j === 0) {
              continue;
            }
            row = node.row + i;
            col = node.col + j;
            tile = game.level.map[row * game.level.rows + col];
            newNode = this.nodeMap[row][col];
            if (tile === "." && (newNode != null ? newNode.state : void 0) !== 'c') {
              if (i * j !== 0) {
                if ((game.level.map[(node.row + i) * game.level.rows + node.col] === ".") && (game.level.map[node.row * game.level.rows + (node.col + j)] === ".")) {
                  movementCost = 14;
                } else {
                  continue;
                }
              } else {
                movementCost = 10;
              }
              if ((newNode != null ? newNode.state : void 0) === 'o') {
                if (node.g + movementCost < newNode.g) {
                  newNode.parent = node;
                  newNode.h = this.getManhattanDistance(col, row);
                  _results1.push(newNode.f = node.g + g + newNode.h);
                } else {
                  _results1.push(void 0);
                }
              } else {
                g = node.g + movementCost;
                h = this.getManhattanDistance(col, row);
                f = g + h;
                _results1.push(this.addToOpenList({
                  col: col,
                  row: row,
                  f: f,
                  g: g,
                  h: h,
                  parent: node
                }));
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Pathfinder.prototype.getManhattanDistance = function(col, row) {
      return (Math.abs(this.targetRow - row) + Math.abs(this.targetCol - col)) * 10;
    };

    Pathfinder.prototype.findSmallestF = function() {
      var i, smallest, _i, _len, _ref;
      smallest = this.open[0];
      _ref = this.open;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (i.f < smallest.f) {
          smallest = i;
        }
      }
      return smallest;
    };

    Pathfinder.prototype.addToOpenList = function(node) {
      node.state = 'o';
      this.nodeMap[node.row][node.col] = node;
      return this.open.push(node);
    };

    return Pathfinder;

  })();

  window.Pathfinder = Pathfinder;

}).call(this);
